% !TEX root=./tech-specification.tex

\section{Collateral for Storage}
\label{sec:collateral}

\emph{Collateral for storage} (CFS for short) mechanism is introduced in \name as a pricing method for the usage of storage,
which is more fair and reasonable 
than the one-off storage fee in Ethereum. 
% 
In principle, this mechanism requires a fund being locked as collateral for any occupation of storage space.
The collateral is locked until the corresponding storage is freed or overwritten by someone else,
and the corresponding interest generated by the locked collateral is assigned directly to miners for the maintenance of storage.
Thus, the cost of storage in \name also depends on the duration of space occupation. 

% For every entry $(k,v)$ in the key/value storage database of any account, \name keeps track of its owner as follows:
% \begin{itemize}[nosep]
% 	\item at the creation of the entry $(k,v)$, the account $\account$ that causes this creation is the owner of this entry; 

% 	\item if another account $\account'(\ne \account)$ modifies the entry into $(k,v')$ by , then the ownership transfers from $\account$ to $\account'$ as well;

% 	\item in case a contract account $\account^*$ activates the function of delegated staking for storage, the owner of corresponding entries can be $\account^*$ instead of the user account who invokes the execution.
% \end{itemize}

In \name, every entry of storage is \sunitsize, which is exactly the size of a single key/value pair in the world-state.
The required collateral for storage is proportional to the smallest multiple of \sunitsize that are capable to cover all stored items.
For every storage entry, the account that last writes to the entry is 
called \emph{the owner of that storage entry}.
If a storage entry is written in the execution of a contract $\contract$ with sponsorship for collateral, 
then $\contract$ is regarded as the account writing to that entry and hence becomes the owner accordingly (see Section~\ref{sec:sponsor} for more details).
In the whole lifetime of a storage entry in the world-state, 
the owner of that entry must lock a fixed amount of \cfx as collateral for the occupation of storage space. 
In particular, for each storage entry of size \sunitsize the owner should lock \sunitprice. 
This price is essentially $1$ \cfx for \storagepertoken space,
i.e. every byte of storage requires $10^{18}/\storagebytepertoken$ \unit.

At the time that an account $\account$ becomes the owner of a storage entry (at either creation or modification), $\account$ should lock \sunitprice for that entry immediately.
If $\account$ has enough balance then the required collateral is locked automatically,
otherwise if $\account$ does not have enough balance, the operation will fail and $\account$ cannot create or change that entry.

When a storage entry is deleted from the world-state, the corresponding \sunitprice collateral is unlocked and returned to the balance of that entry's owner.
In case the ownership of a storage entry is changed, 
the old owner's \sunitprice collateral is unlocked,
while the new owner must lock \sunitprice as collateral at the same time.

For convenience, we introduce the function $\cfs$ which takes an account address $a$ and a world-state $\st$ as input and returns the total amount of \unit's of locked collateral for storage of account $a$ in world-state $\st$.
In case the world-state $\st$ is clear from context, we write $\cfs(a)$ instead of $\cfs(a;\st)$ for succinctness.

\begin{align}
	\cfs(a) \eqdef \cfs(a;\st) \eqdef \text{total number of storage bytes owned by account $a$ in world-state $\st$} 
	\times \frac{10^{18}}{\storagebytepertoken}
\end{align}

In particular, 
for a transaction $\tx$ sent by $\account = \sender{\tx}$ (or $\account=\tx_a$ if $\tx$ is calling a sponsored contract at address $\tx_a$),
let $\st$ be the world-states just before and after the execution of $\tx$, and $\st'$ be world-state at the end of transaction execution, the \textbf{storageLimit} field $\tx_\ell$ asserts that
$\cfs(\account;\st')\le \cfs(\account;\st)+
(10^{18}/\storagebytepertoken)\cdot \tx_\ell$.
